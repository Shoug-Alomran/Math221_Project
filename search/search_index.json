{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Math 221 \u2014 Numerical Analysis Project","text":""},{"location":"#prince-sultan-university","title":"Prince Sultan University","text":"<p>Course: Math 221 \u2014 Numerical Analysis Instructor: Dr. Nahid Fatima Submission Date: 16 November 2025  </p>"},{"location":"#developed-by","title":"Developed by","text":"Name Student ID Role Shoug Fawaz Alomran 223410392 Implementation, documentation, and digital report development Shahad Abunayan 223410189 Mathematical handwritten derivations and theoretical explanation Manar Altuwaim 220410529 Handwritten calculations and verification of numerical results <p>Collaboration Note: This project was completed collaboratively. Shoug Alomran led the implementation, documentation, and site publishing, while Shahad Abunayan and Manar Altuwaim contributed to the handwritten derivations, theoretical analysis, and manual calculations of all numerical methods.</p>"},{"location":"#project-title","title":"Project Title","text":"<p>Comparison of Numerical Methods for Solving Nonlinear Equations (Bisection, Newton\u2013Raphson, and Secant Methods) </p>"},{"location":"#abstract","title":"Abstract","text":"<p>This project studies three numerical methods \u2014 Bisection, Newton\u2013Raphson, and Secant \u2014 to find the root of nonlinear equations that cannot be solved exactly. Each method was implemented using GNU Octave, and the results were compared based on convergence speed, accuracy, and stability.  </p> <p>All three methods reached the same correct root (x = 2). The Newton\u2013Raphson Method converged the fastest, followed by Secant, while Bisection remained the most reliable though slower.</p>"},{"location":"#objectives","title":"Objectives","text":"<ol> <li>Apply and compare classical numerical root-finding methods.  </li> <li>Study their convergence rate, accuracy, and computational efficiency.  </li> <li>Display results through tables and graphs.  </li> <li>Strengthen understanding of iterative numerical analysis through practical implementation.  </li> </ol>"},{"location":"#methods-used","title":"Methods Used","text":"Method Description Characteristics Bisection Method Divides an interval repeatedly to locate the root. Slow but guaranteed convergence. Newton\u2013Raphson Method Uses tangent lines based on derivatives to find the root. Fast but requires a good initial guess. Secant Method Approximates the derivative using two points. Moderate speed and simple to implement."},{"location":"#results-summary","title":"Results Summary","text":"Method Approximate Root Iterations Bisection 2.000000 1 Newton\u2013Raphson 2.000000 5 Secant 2.000000 6 <p>All methods converged to the same root (x = 2). The Newton\u2013Raphson Method was the fastest, confirming the theory discussed in class.</p>"},{"location":"#applications","title":"Applications","text":"<p>Numerical root-finding methods are widely used in: - Engineering and physics modeling - Optimization and computer algorithms - Financial and economic calculations - Simulation and control systems  </p>"},{"location":"#tools-used","title":"Tools Used","text":"<ul> <li>GNU Octave 10.3.0 (compatible with MATLAB)  </li> <li>Visual Studio Code / macOS Terminal </li> <li>MkDocs Material for creating this digital report  </li> <li>Git &amp; GitHub for version control and deployment  </li> </ul>"},{"location":"#references","title":"References","text":"<p>See the complete list in the References section.</p>"},{"location":"abstract/","title":"Abstract","text":"<p>This project focuses on three numerical methods \u2014 Bisection, Newton\u2013Raphson, and Secant \u2014 to find the root of a nonlinear equation. These methods are used when equations cannot be solved exactly and an approximate solution is needed.</p> <p>Each method was implemented using GNU Octave to observe how fast and accurately it converges to the correct root. Through repeated iterations, the methods improve an initial guess until the result becomes very close to the true value.</p> <p>The comparison shows that all three methods reached the same solution (x = 2), but the Newton\u2013Raphson method converged the fastest. The study demonstrates how numerical methods are important in solving practical problems in mathematics, engineering, and computer science where analytical solutions are difficult or impossible to obtain.</p>"},{"location":"applications/","title":"Applications","text":"<p>Numerical methods such as Bisection, Newton\u2013Raphson, and Secant are important tools used to find approximate solutions when equations cannot be solved directly. They are applied in many fields like engineering, computer science, and mathematics, where solving nonlinear equations is required.</p>"},{"location":"applications/#51-engineering-applications","title":"5.1 Engineering Applications","text":"<ul> <li>Mechanical and Civil Engineering: Used to calculate unknown values such as beam deflection, stress, or load in structures.  </li> <li>Electrical Engineering: Helps solve nonlinear circuit equations and control system problems.  </li> <li>Thermodynamics: Used to find equilibrium temperature, pressure, or reaction rates in physical and chemical systems.  </li> <li>Fluid Mechanics: Helps in finding pressure loss, drag force, or flow velocity in pipes and channels.</li> </ul>"},{"location":"applications/#52-computer-science-applications","title":"5.2 Computer Science Applications","text":"<ul> <li>Algorithm Optimization: Many algorithms use iterative methods to find the best or minimum value of a function.  </li> <li>Machine Learning: The Newton\u2013Raphson and Secant methods are used in training algorithms (for example, to find where the error function equals zero).  </li> <li>Simulation and Modeling: Numerical methods are used in computer graphics and game engines to simulate physical systems.  </li> <li>Data Science: Helps in fitting models to data, solving equations that describe trends or predictions.</li> </ul>"},{"location":"applications/#53-mathematics-applications","title":"5.3 Mathematics Applications","text":"<ul> <li>Solving Nonlinear Equations: Used in numerical analysis to approximate roots of equations that have no exact solution.  </li> <li>Modeling: Helps create models in science, economics, and engineering when relationships are nonlinear.  </li> <li>Research and Education: Used to test theories, demonstrate convergence behavior, and analyze accuracy.</li> </ul>"},{"location":"applications/#54-real-world-examples","title":"5.4 Real-World Examples","text":"<ul> <li>Finding rocket trajectory corrections in aerospace engineering.  </li> <li>Predicting chemical equilibrium in laboratory experiments.  </li> <li>Computing interest rates or loan payments in financial calculations.  </li> <li>Designing medical imaging and calibration systems in biomedical applications.</li> </ul>"},{"location":"applications/#55-summary","title":"5.5 Summary","text":"<p>Numerical methods connect mathematical theory with real-world use. Each method has its advantages:</p> <ul> <li>Bisection Method: Always converges but slower.  </li> <li>Newton\u2013Raphson Method: Fast and accurate when the derivative is known.  </li> <li>Secant Method: A good middle option\u2014fast and simple without needing a derivative.  </li> </ul> <p>These methods are essential in many scientific and engineering problems because they provide reliable solutions when exact formulas do not exist.</p>"},{"location":"comparison/","title":"Comparison of Methods","text":"<p>This section compares the three numerical methods used in this project \u2014 Bisection, Newton\u2013Raphson, and Secant \u2014 based on how they find the root, their rate of convergence, and overall behavior. Although all three methods aim to solve \\( f(x) = 0 \\), they differ in how the next value \\( x_{i+1} \\) is calculated from previous iterations.</p>"},{"location":"comparison/#51-bisection-method","title":"5.1 Bisection Method","text":"<ul> <li>The Bisection Method starts with two values \\( a \\) and \\( b \\) such that \\( f(a) \\times f(b) &lt; 0 \\).  </li> <li>The midpoint is found by:   $$   x_{i+1} = \\frac{a + b}{2}   $$  </li> <li>The new interval is then selected based on the sign of \\( f(x_{i+1}) \\).  </li> <li>This process repeats until the difference between \\( a \\) and \\( b \\) becomes very small.</li> </ul> <p>Main Points: - Converges slowly but always works if \\( f(a)f(b) &lt; 0 \\). - Does not need derivatives. - Each step cuts the interval in half.</p>"},{"location":"comparison/#52-newtonraphson-method","title":"5.2 Newton\u2013Raphson Method","text":"<ul> <li>The Newton\u2013Raphson Method uses the tangent line to find where the function crosses the x-axis.  </li> <li>Starting from an initial guess \\( x_0 \\), it applies the formula:   $$   x_{i+1} = x_i - \\frac{f(x_i)}{f'(x_i)}   $$  </li> <li>The next value \\( x_{i+1} \\) is where the tangent line at \\( (x_i, f(x_i)) \\) meets the x-axis.</li> </ul> <p>Main Points: - Very fast convergence if the first guess is close to the actual root. - Needs the first derivative \\( f'(x) \\). - Might diverge if \\( f'(x_i) = 0 \\) or if the first guess is poor.</p>"},{"location":"comparison/#53-secant-method","title":"5.3 Secant Method","text":"<ul> <li>The Secant Method is similar to Newton\u2013Raphson but uses two previous points instead of a derivative.  </li> <li>The formula is:   $$   x_{i+1} = x_i - f(x_i) \\frac{x_i - x_{i-1}}{f(x_i) - f(x_{i-1})}   $$  </li> <li>It uses the slope of the secant line between \\( (x_{i-1}, f(x_{i-1})) \\) and \\( (x_i, f(x_i)) \\).</li> </ul> <p>Main Points: - Faster than Bisection but a bit slower than Newton\u2013Raphson. - No derivative is required. - Can fail if \\( f(x_i) \\) and \\( f(x_{i-1}) \\) are nearly the same.</p>"},{"location":"comparison/#54-summary-of-comparison","title":"5.4 Summary of Comparison","text":"Feature Bisection Newton\u2013Raphson Secant Derivative Required No Yes No Initial Guesses Two points \\( a, b \\) One point \\( x_0 \\) Two points \\( x_0, x_1 \\) Formula \\( x_{i+1} = \\frac{a + b}{2} \\) \\( x_{i+1} = x_i - \\frac{f(x_i)}{f'(x_i)} \\) \\( x_{i+1} = x_i - f(x_i) \\frac{x_i - x_{i-1}}{f(x_i) - f(x_{i-1})} \\) Convergence Speed Slow Fast Moderate Stability Always convergent May diverge May diverge Ease of Use Very Easy Moderate Easy"},{"location":"comparison/#55-final-remarks","title":"5.5 Final Remarks","text":"<ul> <li>The Bisection Method is the safest and always converges but is the slowest.  </li> <li>The Newton\u2013Raphson Method is the fastest and most accurate if the derivative is available.  </li> <li>The Secant Method provides a balance \u2014 it is faster than Bisection and simpler than Newton\u2013Raphson.  </li> </ul> <p>Overall, the Newton\u2013Raphson method performed best in this project because it reached the correct root in fewer iterations, while all three methods produced the same final result (x = 2).</p>"},{"location":"conclusion/","title":"Conclusion","text":"<p>This project used three numerical methods \u2014 Bisection, Newton\u2013Raphson, and Secant \u2014 to find the root of nonlinear equations that cannot be solved exactly. Each method was tested and compared to study how fast and accurately it converges to the correct solution.</p>"},{"location":"conclusion/#61-summary-of-findings","title":"6.1 Summary of Findings","text":"<ul> <li>All three methods found the same root for \\( f(x) = x^2 - 4 \\), which is x = 2.  </li> <li>The Bisection Method was the most reliable since it always converges when the function changes sign in the interval.  </li> <li>The Newton\u2013Raphson Method was the fastest, reaching the correct answer in the fewest steps.  </li> <li>The Secant Method gave accurate results without needing the derivative and was faster than Bisection.</li> </ul> <p>These results agree with what was expected from the course material and slides \u2014 Newton\u2013Raphson has the highest speed, while Bisection guarantees convergence.</p>"},{"location":"conclusion/#62-reflection","title":"6.2 Reflection","text":"<p>Through this project, we learned how: - Iterative methods gradually move closer to the root. - Each method has different trade-offs between speed, accuracy, and stability. - The choice of initial guess and tolerance affects how well the method performs.</p> <p>By using GNU Octave, we were able to apply the mathematical theory directly through coding. This helped connect what was learned in class with practical problem-solving using software tools.</p>"},{"location":"conclusion/#63-future-work","title":"6.3 Future Work","text":"<p>To improve this project in the future, we could: - Add graphical visualizations to show how the root changes with each iteration. - Apply the methods to different functions or systems of equations. - Compare these methods with other techniques like Fixed-Point Iteration or Hybrid Methods to study more complex cases.</p>"},{"location":"conclusion/#64-final-thoughts","title":"6.4 Final Thoughts","text":"<p>This project shows how numerical methods are powerful tools in mathematics and engineering. Even when a problem has no exact solution, these techniques allow us to find accurate approximations. Among the three methods, Newton\u2013Raphson proved to be the fastest, but Bisection remains the most dependable when accuracy and guaranteed convergence are needed.</p>"},{"location":"introduction/","title":"Introduction","text":"<p>Numerical Analysis is a branch of applied mathematics that provides methods to find approximate solutions when exact analytical solutions are not possible. In many real problems, equations cannot be solved by simple algebra, especially when they are nonlinear. In such cases, numerical methods are used to find values of \\( x \\) that satisfy:</p> \\[ f(x) = 0 \\] <p>where the root \\( x \\) represents the point at which the function crosses the x-axis. These types of problems are common in engineering, physics, and computer science, where models are based on complex mathematical relationships.</p> <p>This project studies three important numerical methods for solving nonlinear equations: Bisection, Newton\u2013Raphson, and Secant. Each of these methods uses an iterative process \u2014 starting from one or more initial guesses and improving them step by step until the result is close to the true root.</p> <p>The main goals of this project are to: - Implement each method using GNU Octave (MATLAB-compatible software). - Compare the methods in terms of speed of convergence, accuracy, and number of iterations. - Relate the methods to practical applications in science and engineering.</p> <p>By completing this project, students gain a clearer understanding of how numerical algorithms work and why they are important in real-world problem solving, optimization, and simulation. These methods show how mathematics can be applied using computers to solve problems that would otherwise be too difficult to handle analytically.</p>"},{"location":"methods/","title":"Methods","text":"<p>This section explains the three numerical methods used in this project to find the root of a nonlinear equation: Bisection, Newton\u2013Raphson, and Secant. Each method improves an initial guess step by step until the value of \\( x \\) becomes close enough to the actual root within a chosen tolerance.</p>"},{"location":"methods/#1-bisection-method","title":"1. Bisection Method","text":"<p>The Bisection Method is a simple and reliable way to find a root by dividing an interval in half repeatedly and choosing the part where the function changes sign. It is based on the Intermediate Value Theorem, which states that if \\( f(a) \\) and \\( f(b) \\) have opposite signs, then there is at least one root between them.</p> <p>Procedure: 1. Choose two values \\( a \\) and \\( b \\) such that \\( f(a) \\times f(b) &lt; 0 \\). 2. Find the midpoint:  </p> \\[ x_{i+1} = \\frac{a + b}{2} \\] <ol> <li>Check the sign of \\( f(x_{i+1}) \\):  </li> <li>If \\( f(a) \\times f(x_{i+1}) &lt; 0 \\), set \\( b = x_{i+1} \\).  </li> <li>Otherwise, set \\( a = x_{i+1} \\).  </li> <li>Continue until the interval \\( |b - a| \\) is smaller than the chosen tolerance \\( \\varepsilon \\).  </li> </ol> <p>Stopping Criterion: </p> \\[ |f(x_{i+1})| &lt; \\varepsilon \\] <p>Advantages: - Always converges if \\( f(a)f(b) &lt; 0 \\). - Simple and easy to apply.  </p> <p>Limitations: - Convergence is slow. - Requires that the initial interval contains a sign change.  </p>"},{"location":"methods/#2-newtonraphson-method","title":"2. Newton\u2013Raphson Method","text":"<p>The Newton\u2013Raphson Method uses the tangent line at a point to find where the function crosses the x-axis. It requires the derivative \\( f'(x) \\) and a good initial guess \\( x_0 \\).</p> <p>Formula: </p> \\[ x_{i+1} = x_i - \\frac{f(x_i)}{f'(x_i)} \\] <p>Procedure: 1. Choose a starting value \\( x_0 \\). 2. Use the formula to calculate a new value \\( x_{i+1} \\). 3. Repeat until \\( |x_{i+1} - x_i| &lt; \\varepsilon \\).  </p> <p>Advantages: - Very fast (quadratic) convergence if the first guess is close to the root. - Needs fewer iterations than other methods.  </p> <p>Limitations: - Requires the derivative \\( f'(x) \\). - May fail if \\( f'(x_i) = 0 \\) or if the first guess is not near the root.  </p>"},{"location":"methods/#3-secant-method","title":"3. Secant Method","text":"<p>The Secant Method is similar to Newton\u2013Raphson but does not require a derivative. Instead, it estimates the slope using two recent points.</p> <p>Formula: </p> \\[ x_{i+1} = x_i - f(x_i) \\frac{x_i - x_{i-1}}{f(x_i) - f(x_{i-1})} \\] <p>Procedure: 1. Choose two initial guesses \\( x_0 \\) and \\( x_1 \\). 2. Use the formula to find \\( x_{i+1} \\). 3. Repeat until \\( |x_{i+1} - x_i| &lt; \\varepsilon \\).  </p> <p>Advantages: - Faster than Bisection and does not need the derivative. - Easier to apply than Newton\u2013Raphson.  </p> <p>Limitations: - May fail if \\( f(x_i) \\) and \\( f(x_{i-1}) \\) are almost the same. - Convergence is slower than Newton\u2013Raphson.  </p>"},{"location":"methods/#summary-of-methods","title":"Summary of Methods","text":"Method Requires Derivative Convergence Speed Reliability Notes Bisection No Slow Always convergent Simple and reliable Newton\u2013Raphson Yes Fast Depends on initial guess Needs \\( f'(x) \\) Secant No Moderate Depends on initial guesses Approximates derivative"},{"location":"references/","title":"References","text":"<ol> <li>Burden, R. L., &amp; Faires, J. D. (2010). Numerical Analysis (9th ed.). Brooks/Cole, Cengage Learning.  </li> <li>Chapra, S. C., &amp; Canale, R. P. (2015). Numerical Methods for Engineers (7th ed.). McGraw-Hill Education.  </li> <li>Kiusalaas, J. (2013). Numerical Methods in Engineering with Python 3. Cambridge University Press.  </li> <li>Mathews, J. H., &amp; Fink, K. D. (2004). Numerical Methods Using MATLAB (4th ed.). Pearson Prentice Hall.  </li> <li>Atkinson, K. E. (1989). An Introduction to Numerical Analysis (2nd ed.). John Wiley &amp; Sons.  </li> <li>GNU Octave Project. (2024). GNU Octave Documentation. Retrieved from https://www.gnu.org/software/octave/ </li> <li>MathWorks. (2024). MATLAB Documentation \u2014 Numerical Computation. Retrieved from https://www.mathworks.com/help/matlab/ </li> <li>Prince Sultan University. (2025). Math 221 \u2014 Numerical Analysis Course Materials. Department of Mathematics and Sciences.  </li> </ol> <p>Note: All numerical examples and Octave/MATLAB implementations were developed as part of the Math 221: Numerical Analysis course project at Prince Sultan University (Fall 2025).</p>"},{"location":"results/","title":"Results","text":"<p>This section presents the results obtained from applying the Bisection, Newton\u2013Raphson, and Secant methods to solve a nonlinear equation. All methods were implemented in GNU Octave to compare their convergence, number of iterations, and overall accuracy.</p>"},{"location":"results/#41-function-used","title":"4.1 Function Used","text":"<p>The function chosen for analysis is:</p> \\[ f(x) = x^2 - 4 \\] <p>The exact root of this function is \\( x = 2 \\), since \\( 2^2 - 4 = 0 \\). This function was selected because it is simple yet suitable for observing the convergence behavior of each method.</p>"},{"location":"results/#42-iterative-results","title":"4.2 Iterative Results","text":"<p>Each method was executed in GNU Octave 10.3.0 (compatible with MATLAB). The table below summarizes the number of iterations required to reach the approximate root using a tolerance of \\( 10^{-6} \\):</p> Method Approximate Root Iterations Remarks Bisection 2.000000 1 Fast convergence due to midpoint symmetry. Newton\u2013Raphson 2.000000 5 Fast quadratic convergence. Secant 2.000000 6 Slightly slower but accurate without derivative. <p>All three methods successfully reached the same root, \\( x = 2 \\). Among them, the Newton\u2013Raphson Method converged the fastest.</p>"},{"location":"results/#43-sample-output-from-octave","title":"4.3 Sample Output from Octave","text":"<p>Below is an example of the terminal output for the Newton\u2013Raphson Method:</p> <pre><code>Enter initial guess x0 = 1\nEnter tolerance = 1e-6\n\nIteration 1: x1 = 2.500000, f(x1) = 2.250000\nIteration 2: x2 = 2.050000, f(x2) = 0.202500\nIteration 3: x3 = 2.000610, f(x3) = 0.002441\nIteration 4: x4 = 2.000000, f(x4) = 0.000000\nRoot found at x = 2.000000 after 5 iterations\n</code></pre>"},{"location":"results/#44-graphical-representation","title":"4.4 Graphical Representation","text":"<p>The figures below illustrate the computational results and graphical output obtained in GNU Octave for the three numerical methods.</p>"},{"location":"results/#figure-2-graph-output","title":"Figure 2: Graph Output","text":"<p>Figure 2: Plot of the function \\(f(x) = x^2 - 4\\) showing convergence of methods toward the true root \\(x = 2\\).</p>"},{"location":"results/#45-observations","title":"4.5 Observations","text":"<ul> <li>All three methods converged to the same solution with very small error.  </li> <li>The Newton\u2013Raphson Method showed the fastest convergence because of its quadratic rate.  </li> <li>The Bisection Method was the most stable but required fewer computational steps in this special case.  </li> <li>The Secant Method performed well without the need for derivatives.  </li> <li>In all methods, the error decreased steadily as the number of iterations increased.</li> </ul>"},{"location":"results/#46-error-vs-iteration","title":"4.6 Error vs. Iteration","text":"<p>The error plot illustrates how each method\u2019s error value decreases with each iteration. The Newton\u2013Raphson Method shows the steepest drop in error, confirming that it converges faster than the Bisection and Secant methods. This agrees with the expected theoretical behavior discussed in the course.</p>"},{"location":"results/#47-summary-of-results","title":"4.7 Summary of Results","text":"Metric Bisection Newton\u2013Raphson Secant Root Found 2.000000 2.000000 2.000000 Iterations 1 5 6 Derivative Required No Yes No Convergence Type Linear Quadratic Superlinear Stability High Medium Medium <p>All three methods produced the same correct root \\( x = 2 \\). However, the Newton\u2013Raphson Method was the most efficient because it reached the solution with fewer iterations and high precision.  </p>"},{"location":"results/#48-conclusion-of-findings","title":"4.8 Conclusion of Findings","text":"<p>The experiment confirmed the theoretical performance of each numerical method:  </p> <ul> <li>The Bisection Method always converges but is relatively slow.  </li> <li>The Newton\u2013Raphson Method is the fastest when the derivative and a good initial guess are available.  </li> <li>The Secant Method offers a practical compromise when the derivative is unknown.  </li> </ul> <p>These results are consistent with the concepts learned in class and demonstrate how each method behaves in practice. They also show the importance of selecting the right numerical method depending on the type of equation and the information available.</p>"},{"location":"report/","title":"Project Report","text":"<p>View the report online</p>"}]}